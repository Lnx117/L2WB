package main

func main() {
	//Реализуем device
	tv := &tv{}

	//Создаем наши команды
	onCommand := &onCommand{
		device: tv,
	}

	offCommand := &offCommand{
		device: tv,
	}

	//Передаем команды в отправитель
	onButton := &button{
		command: onCommand,
	}
	//Используем отправитель для активации команды по цепочке
	onButton.press()

	offButton := &button{
		command: offCommand,
	}
	offButton.press()
}

/*
Преимущества и недостатки
+ Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
+ Позволяет реализовать простую отмену и повтор операций.
+ Позволяет реализовать отложенный запуск операций.
+ Позволяет собирать сложные команды из простых.
+ Реализует принцип открытости/закрытости.

-Усложняет код программы из-за введения множества дополнительных классов.


Давайте рассмотрим паттерн Команда на примере телевизора. ТV может быть включен двумя способами:

кнопка ВКЛ на пульте дистанционного управления;
кнопка ВКЛ на самом телевизоре.
Мы можем начать с реализации объекта команды ВКЛ с телевизором в роли получателя.
Когда на эту команду вызывается метод execute, она, в свою очередь, вызывает функцию TV.on.
Вышеуказанное определяет вызывающий объект. На самом деле мы будем иметь два вызывающих объекта: пульт и сам ТВ.
Оба будут содержать объект команды ВКЛ.

Заметьте, что мы обернули один и тот же запрос в несколько вызывающих объектов.
Это же можно делать и с другими командами. Преимуществом создания отдельных объектов команд является отделение логики
пользовательского интерфейса от внутренней бизнес-логики. Нет нужды разрабатывать отдельные исполнители для каждого
вызывающего объекта – сама команда содержит всю информацию, необходимую для ее исполнения. Соответственно, ее можно
использовать для отсроченного выполнения задачи.

*/
