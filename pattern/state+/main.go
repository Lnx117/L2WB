package main

import (
	"fmt"
	"log"
)

func main() {
	vendingMachine := newVendingMachine(1, 10)

	err := vendingMachine.requestItem()
	if err != nil {
		log.Fatalf(err.Error())
	}

	err = vendingMachine.insertMoney(10)
	if err != nil {
		log.Fatalf(err.Error())
	}

	err = vendingMachine.dispenseItem()
	if err != nil {
		log.Fatalf(err.Error())
	}

	fmt.Println()

	err = vendingMachine.addItem(2)
	if err != nil {
		log.Fatalf(err.Error())
	}

	fmt.Println()

	err = vendingMachine.requestItem()
	if err != nil {
		log.Fatalf(err.Error())
	}

	err = vendingMachine.insertMoney(10)
	if err != nil {
		log.Fatalf(err.Error())
	}

	err = vendingMachine.dispenseItem()
	if err != nil {
		log.Fatalf(err.Error())
	}
}

/*
Состояние — это поведенческий паттерн, позволяющий динамически изменять поведение объекта при смене его состояния.

Преимущества и недостатки:
+ Избавляет от множества больших условных операторов машины состояний.
+ Упрощает код контекста.
+ Концентрирует в одном месте код, связанный с определённым состоянием.

- Может неоправданно усложнить код, если состояний мало и они редко меняются.



Давайте применим паттерн проектирования Состояние в контексте торговых автоматов.
Для упрощения задачи представим, что торговый автомат может выдавать только один товар.
Также представим, что автомат может пребывать только в одном из четырех состояний:

hasItem (имеетПредмет)
noItem (неИмеетПредмет)
itemRequested (выдаётПредмет)
hasMoney (получилДеньги)
Торговый автомат может иметь различные действия. Опять-таки, для простоты оставим только четыре из них:

Выбрать предмет
Добавить предмет
Ввести деньги
Выдать предмет
Паттерн Состояние нужно использовать в случаях, когда объект может иметь много различных состояний, которые он должен менять в
 зависимости от конкретного поступившего запроса.

В нашем примере, автомат может быть в одном из множества состояний, которые непрерывно меняются.
Припустим, что торговый автомат находится в режиме itemRequested.
Как только произойдет действие «Ввести деньги», он сразу же перейдет в состояние hasMoney.

В зависимости от состояния торгового автомата, в котором он находится на данный момент,
он может по-разному отвечать на одни и те же запросы. Например, если пользователь хочет купить предмет,
машина выполнит действие, если она находится в режиме hasItemState, и отклонит запрос в режиме noItemState.

Программа торгового автомата не захламлена этой логикой; весь режимозависимый код обитает в реализациях соответствующих состояний.



Есть объект автомата, у него есть различные состояния
Для каждого состояния реализуется интерфейс. В каждом состоянии расписано действие для любого варианта
событий.
*/
